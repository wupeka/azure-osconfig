#include <string>
#include <memory>
#include <map>
#include <sstream>

#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdarg.h>
#include <version.h>
#include <ctype.h>
#include <parson.h>
#include <CommonUtils.h>
#include <UserUtils.h>
#include <SshUtils.h>
#include <Logging.h>


#include "Compliance.h"
#include "ComplianceInt.hpp"
#include "base64.h"

// autogenerated in ProcedureMap.cpp
extern std::map<std::string, std::pair<action_func_t, action_func_t>> complianceProcedureMap;

static int mapUserParameters(const std::string& input, std::map<std::string, std::string>& parameters, void* log)
{
    // Update map with values from input string
    std::istringstream stream(input);
    std::string token;

    while (std::getline(stream, token, ' '))
    {
        // In the non-NRP scenario the token is delimited by double quotes
        if (token.size() >= 2 && token.front() == '"' && token.back() == '"')
        {
            token = token.substr(1, token.size() - 2);
        }

        size_t pos = token.find('=');
        if (pos == std::string::npos)
        {
            continue;
        }

        std::string key = token.substr(0, pos);
        std::string value = token.substr(pos + 1);

        if (!value.empty() && value[0] == '"')
        {
            value.erase(0, 1);
            while (!value.empty() && value.back() == '\\')
            {
                std::string nextToken;
                if (std::getline(stream, nextToken, ' '))
                {
                    value.pop_back();
                    value += ' ' + nextToken;
                }
                else
                {
                    break;
                }
            }
            if (!value.empty() && value.back() == '"')
            {
                value.pop_back();
            }
        }

        auto it = parameters.find(key);
        if (it == parameters.end())
        {
            OsConfigLogError(log, "Unknown parameter %s", key.c_str());
            return EINVAL;
        }

        it->second = value;
    }

    return 0;
}

int ComplianceIsValidResourceIdRuleId(const char *resourceId, const char *ruleId, const char *payloadKey, void *log)
{
    (void) resourceId;
    (void) ruleId;
    (void) payloadKey;
    (void) log;
    return 0;
};

tristate_t EvaluateProcedure(const JSON_Object* json, const Action action, const std::map<std::string, std::string>& parameters, std::ostringstream& logstream, void* log)
{
    // checks!
    const char *name = json_object_get_name(json, 0);
    JSON_Value* value = json_object_get_value_at(json, 0);

    // auto str = json_serialize_to_string_pretty(json_object_get_wrapping_value(json));
    // OsConfigLogInfo(log, "Evaluating procedure: %s", str);
    // free(str);
    if (!strcmp(name, "anyOf"))
    {
        if (json_value_get_type(value) != JSONArray)
        {
            logstream << "ERROR: anyOf value is not an array";
            return FAILURE;
        }
        JSON_Array *array = json_value_get_array(value);
        size_t count = json_array_get_count(array);
        logstream << "{ anyOf: [";
        for (size_t i = 0; i < count; ++i)
        {
            JSON_Object *subObject = json_array_get_object(array, i);
            tristate_t result = EvaluateProcedure(subObject, action, parameters, logstream, log);
            switch (result)
            {
            case TRUE:
                logstream << "] == TRUE }";
                return result;
            case FALSE:
                if (i < count - 1)
                {
                    logstream << ", ";
                }
                break;
            case FAILURE:
                logstream << "] == FAILURE }";
                return result;
            }
        }
        logstream << "] == FALSE }";
        return FALSE;
    }
    else if (!strcmp(name, "allOf"))
    {
        if (json_value_get_type(value) != JSONArray)
        {
            logstream << "ERROR: allOf value is not an array";
            return FAILURE;
        }
        JSON_Array *array = json_value_get_array(value);
        size_t count = json_array_get_count(array);
        logstream << "{ allOf: [";
        for (size_t i = 0; i < count; ++i)
        {
            JSON_Object *subObject = json_array_get_object(array, i);
            tristate_t result = EvaluateProcedure(subObject, action, parameters, logstream, log);
            switch (result)
            {
            case TRUE:
                if (i < count - 1)
                {
                    logstream << ", ";
                }
                break;
            case FALSE:
                logstream << "] == FALSE }";
                return result;
            case FAILURE:
                logstream << "] == FAILURE }";
                return result;
            }
        }
        logstream << "] == TRUE }";
        return TRUE;
    }
    else if (!strcmp(name, "not"))
    {
        if (json_value_get_type(value) != JSONObject)
        {
            logstream << "ERROR: not value is not an object";
            return FAILURE;
        }
        logstream << "{ not: ";
        // NOT can be only used as an audit!
        tristate_t rv = EvaluateProcedure(json_value_get_object(value), Action::Audit, parameters, logstream, log);
        switch (rv)
        {
        case TRUE:
            logstream << " } == FALSE";
            return FALSE;
        case FALSE:
            logstream << " } == TRUE";
            return TRUE;
        case FAILURE:
            logstream << " } == FAILURE";
            return FAILURE;
        }
    }
    else
    {
        if (json_value_get_type(value) != JSONObject)
        {
            return FAILURE;
        }
        std::map<std::string, std::string> arguments;
        JSON_Object *args_object = json_value_get_object(value);
        size_t count = json_object_get_count(args_object);
        for (size_t i = 0; i < count; ++i)
        {
            const char *key = json_object_get_name(args_object, i);
            JSON_Value *val = json_object_get_value_at(args_object, i);
            if (json_value_get_type(val) != JSONString)
            {
                return FAILURE;
            }
            arguments[key] = json_value_get_string(val);
            if (!arguments[key].empty() && arguments[key][0] == '$')
            {
                auto f = parameters.find(arguments[key].substr(1));
                if (f == parameters.end())
                {
                    logstream << "ERROR: Unknown parameter " << arguments[key];
                    return FAILURE;
                }
                arguments[key] = f->second;
            }
        }

        auto f = complianceProcedureMap.find(name);
        if (f == complianceProcedureMap.end())
        {
            logstream << "ERROR: Unknown function " << name;
            return FAILURE;
        }
        action_func_t fn;
        if (action == Action::Remediate)
        {
            fn = f->second.second;
            if (fn == NULL)
            {
                fn = f->second.first;
            }
            if (fn == NULL)
            {
                return FAILURE;
            }
        }
        else
        {
            fn = f->second.first;
        }
        if (fn == NULL)
        {
            return FAILURE;
        }
        logstream << "{ " << name << ": ";
        tristate_t result = fn(name, arguments, logstream, log);
        logstream << " } == ";
        switch (result)
        {
        case TRUE:
            logstream << "TRUE";
            break;
        case FALSE:
            logstream << "FALSE";
            break;
        case FAILURE:
            logstream << "FAILURE";
            break;
        }
        return result;
    }
    return FAILURE; // unreachable
}

int ComplianceExecuteAudit(const json_object_t* rule, const std::map<std::string, std::string>& parameters, char** payload, int* payloadSizeBytes, void* log) {
    tristate_t result = FAILURE;
    std::ostringstream logstream;

    if (rule == nullptr)
    {
        return EINVAL;
    }

    result = EvaluateProcedure(rule, Action::Audit, parameters, logstream, log);
    if (result == FAILURE)
    {
        OsConfigLogError(log, "ComplianceMmiGet failed to evaluate procedure - %s", logstream.str().c_str());
        return EINVAL;
    }

    std::string vlog = logstream.str().substr(0, 4096 - (1 + 4 + 2)); // 4 for "PASS" or "FAIL", 2 for quotes
    if (result == TRUE)
    {
        vlog = "\"PASS" + vlog + "\"";
    }
    else
    {
        vlog = "\"" + vlog + "\"";
    }
    *payloadSizeBytes = vlog.size();
    *payload = (char*)malloc(*payloadSizeBytes + 1);
    (*payload)[*payloadSizeBytes] = '\0';
    memcpy(*payload, vlog.c_str(), *payloadSizeBytes);
    OsConfigLogInfo(log, "ComplianceExecuteRule() completed: '%s'", vlog.c_str());
    return 0;
};

int ComplianceExecuteRemediation(const JSON_Object* rule, std::map<std::string, std::string> parameters, const char* payload, int payloadSizeBytes, void* log) {
    std::ostringstream logstream;

    if(mapUserParameters(payload, parameters, log) != 0)
    {
        OsConfigLogError(log, "ComplianceExecuteSetRule failed to map user parameters");
        return EINVAL;
    }

    if (EvaluateProcedure(rule, Action::Remediate, parameters, logstream, log) != TRUE)
    {
        OsConfigLogError(log, "ComplianceExecuteSetRule failed to evaluate procedure - %s", logstream.str().c_str());
        return EINVAL;
    }

    OsConfigLogInfo(log, "ComplianceExecuteSetRule(%p, %.*s, %d) completed, result log '%s'", rule, payloadSizeBytes, payload, payloadSizeBytes, logstream.str().c_str());
    return 0;
};

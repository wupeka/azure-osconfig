#include <string>
#include <memory>
#include <map>
#include <sstream>

#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdarg.h>
#include <version.h>
#include <ctype.h>
#include <parson.h>
#include <CommonUtils.h>
#include <UserUtils.h>
#include <SshUtils.h>
#include <Logging.h>


#include "Compliance.h"
#include "ComplianceInt.hpp"
#include "base64.h"

// autogenerated in ProcedureMap.cpp
extern std::map<std::string, std::pair<action_func_t, action_func_t>> complianceProcedureMap;

// state part...
static std::map<std::string, std::string> gParameters;

static std::map<std::string, std::string> parseParameters(JSON_Object *jsonObject, const std::string &input)
{
    std::map<std::string, std::string> result;
    size_t count = json_object_get_count(jsonObject);
    for (size_t i = 0; i < count; ++i) {
        const char *key = json_object_get_name(jsonObject, i);
        const char *value = json_object_get_string(jsonObject, key);
        if (key && value) {
            result[key] = value;
        }
    }

    // Update map with values from input string
    std::istringstream stream(input);
    std::string token;

    while (std::getline(stream, token, ' '))
    {
        size_t pos = token.find('=');
        if (pos == std::string::npos)
        {
            continue;
        }

        std::string key = token.substr(0, pos);
        std::string value = token.substr(pos + 1);

        if (!value.empty() && value[0] == '"')
        {
            value.erase(0, 1);
            while (!value.empty() && value.back() == '\\')
            {
                std::string nextToken;
                if (std::getline(stream, nextToken, ' '))
                {
                    value.pop_back();
                    value += ' ' + nextToken;
                }
                else
                {
                    break;
                }
            }
            if (!value.empty() && value.back() == '"')
            {
                value.pop_back();
            }
        }

        result[key] = value;
    }

    return result;
}


int ComplianceIsValidResourceIdRuleId(const char *resourceId, const char *ruleId, const char *payloadKey, void *log)
{
    (void) resourceId;
    (void) ruleId;
    (void) payloadKey;
    (void) log;
    return 0;
};

static int DecodeB64JSON(const char *input, JSON_Value **output)
{
    unsigned int baseLen = 0;
    JSON_Value *inputJSON = NULL;

    Base64Decode(input, NULL, &baseLen);
    if (0 == baseLen) {
        return EINVAL;
    }

    std::shared_ptr<char> inputJSONString(new char[baseLen], std::default_delete<char[]>());

    if (Base64Decode(input, (unsigned char *)inputJSONString.get(), &baseLen) != 0)
    {
        return EINVAL;
    }

    inputJSON = json_parse_string(inputJSONString.get());
    if (NULL == inputJSON) {
        return EINVAL;
    }

    *output = inputJSON;
    return 0;
}

tristate_t EvaluateProcedure(JSON_Object *json, bool remediate, std::ostringstream &logstream, void *log)
{
    // checks!
    const char *name = json_object_get_name(json, 0);
    JSON_Value *value = json_object_get_value_at(json, 0);
    if (!strcmp(name, "anyOf"))
    {
        if (json_value_get_type(value) != JSONArray)
        {
            logstream << "ERROR: anyOf value is not an array";
            return FAILURE;
        }
        JSON_Array *array = json_value_get_array(value);
        size_t count = json_array_get_count(array);
        logstream << "{ anyOf: [";
        for (size_t i = 0; i < count; ++i)
        {
            JSON_Object *subObject = json_array_get_object(array, i);
            tristate_t result = EvaluateProcedure(subObject, remediate, logstream, log);
            switch (result)
            {
            case TRUE:
                logstream << "] == TRUE }";
                return result;
            case FALSE:
                if (i < count - 1)
                {
                    logstream << ", ";
                }
                break;
            case FAILURE:
                logstream << "] == FAILURE }";
                return result;
            }
        }
        logstream << "] == FALSE }";
        return FALSE;
    }
    else if (!strcmp(name, "allOf"))
    {
        if (json_value_get_type(value) != JSONArray)
        {
            logstream << "ERROR: allOf value is not an array";
            return FAILURE;
        }
        JSON_Array *array = json_value_get_array(value);
        size_t count = json_array_get_count(array);
        logstream << "{ allOf: [";
        for (size_t i = 0; i < count; ++i)
        {
            JSON_Object *subObject = json_array_get_object(array, i);
            tristate_t result = EvaluateProcedure(subObject, remediate, logstream, log);
            switch (result)
            {
            case TRUE:
                if (i < count - 1)
                {
                    logstream << ", ";
                }
                break;
            case FALSE:
                logstream << "] == FALSE }";
                return result;
            case FAILURE:
                logstream << "] == FAILURE }";
                return result;
            }
        }
        logstream << "] == TRUE }";
        return TRUE;
    }
    else if (!strcmp(name, "not"))
    {
        if (json_value_get_type(value) != JSONObject)
        {
            logstream << "ERROR: not value is not an object";
            return FAILURE;
        }
        logstream << "{ not: ";
        // NOT can be only used as an audit!
        tristate_t rv = EvaluateProcedure(json_value_get_object(value), false, logstream, log);
        switch (rv)
        {
        case TRUE:
            logstream << " } == FALSE";
            return FALSE;
        case FALSE:
            logstream << " } == TRUE";
            return TRUE;
        case FAILURE:
            logstream << " } == FAILURE";
            return FAILURE;
        }
    }
    else
    {
        if (json_value_get_type(value) != JSONObject)
        {
            return FAILURE;
        }
        std::map<std::string, std::string> arguments;
        JSON_Object *args_object = json_value_get_object(value);
        size_t count = json_object_get_count(args_object);
        for (size_t i = 0; i < count; ++i)
        {
            const char *key = json_object_get_name(args_object, i);
            JSON_Value *val = json_object_get_value_at(args_object, i);
            if (json_value_get_type(val) != JSONString)
            {
                return FAILURE;
            }
            arguments[key] = json_value_get_string(val);
            if (!arguments[key].empty() && arguments[key][0] == '$')
            {
                auto f = gParameters.find(arguments[key].substr(1));
                if (f == gParameters.end())
                {
                    logstream << "ERROR: Unknown parameter " << arguments[key];
                    return FAILURE;
                }
                arguments[key] = f->second;
            }
        }

        auto f = complianceProcedureMap.find(name);
        if (f == complianceProcedureMap.end())
        {
            logstream << "ERROR: Unknown function " << name;
            return FAILURE;
        }
        action_func_t fn;
        if (remediate)
        {
            fn = f->second.second;
            if (fn == NULL)
            {
                fn = f->second.first;
            }
            if (fn == NULL)
            {
                return FAILURE;
            }
        }
        else
        {
            fn = f->second.first;
        }
        if (fn == NULL)
        {
            return FAILURE;
        }
        logstream << "{ " << name << ": ";
        tristate_t result = fn(name, arguments, logstream, log);
        logstream << " } == ";
        switch (result)
        {
        case TRUE:
            logstream << "TRUE";
            break;
        case FALSE:
            logstream << "FALSE";
            break;
        case FAILURE:
            logstream << "FAILURE";
            break;
        }
        return result;
    }
    return FAILURE; // unreachable
}

void ComplianceInitialize(void *log) {
    (void)log;

};
void ComplianceShutdown(void *log) {
    (void)log;
};

int ComplianceMmiGet(const char *componentName, const char *objectName, char **payload, int *payloadSizeBytes, unsigned int maxPayloadSizeBytes, void *log) {
    int status = 0;
    tristate_t result = FAILURE;
    std::ostringstream logstream;

    OsConfigLogInfo(log, "ComplianceMmiGet(%s, %s, %s, %p) called with arguments", componentName, objectName, *payload, payloadSizeBytes);

    if ((NULL == componentName) || (NULL == objectName) || (NULL == payload) || (NULL == payloadSizeBytes))
    {
        OsConfigLogError(log, "ComplianceMmiGet(%s, %s, %p, %p) called with invalid arguments", componentName, objectName, payload, payloadSizeBytes);
        return EINVAL;
    }

    JSON_Value *inputJSON = NULL;
    status = DecodeB64JSON(objectName, &inputJSON);
    if (0 != status) {
        OsConfigLogError(log, "ComplianceMmiGet failed to decode input JSON %s", objectName);
        return status;
    }
    std::shared_ptr<JSON_Value> inputJSONPtr(inputJSON, json_value_free);
    if (json_value_get_type(inputJSON) != JSONObject) {
        OsConfigLogError(log, "ComplianceMmiGet input JSON is not an object");
        return EINVAL;
    }

    JSON_Object *root = json_value_get_object(inputJSON);
    const char *name = json_object_get_name(root, 0);
    JSON_Value *value = json_object_get_value_at(root, 0);

    if (json_value_get_type(value) != JSONObject) {
        OsConfigLogError(log, "ComplianceMmiGet audit JSON is not an object");
        return EINVAL;
    }

    if (!strcmp(name, "audit")) {
        JSON_Object *subObject = json_value_get_object(value);
        result = EvaluateProcedure(subObject, false, logstream, log);
    } else {
        OsConfigLogError(log, "ComplianceMmiGet root JSON is not an audit object");
        return EINVAL;
    }
    
    if (result == FAILURE) {
        OsConfigLogError(log, "ComplianceMmiGet failed to evaluate procedure - %s", logstream.str().c_str());
        return EINVAL;
    }
    std::string vlog = logstream.str().substr(0, maxPayloadSizeBytes - (1 + 4 + 2)); // 4 for "PASS" or "FAIL", 2 for quotes
    if (result == TRUE) {
        vlog = "\"PASS" + vlog + "\"";
    } else {
        vlog = "\"" + vlog + "\"";
    }
    *payloadSizeBytes = vlog.size();
    *payload = (char *)malloc(*payloadSizeBytes + 1);
    (*payload)[*payloadSizeBytes] = '\0';
    memcpy(*payload, vlog.c_str(), *payloadSizeBytes);
    return 0;
};

int ComplianceMmiSet(const char *componentName, const char *objectName, const char *payload, const int payloadSizeBytes, void *log) {
    int status = 0; 
    std::ostringstream logstream;
    OsConfigLogInfo(log, "ComplianceMmiSet(%s, %s, %s, %d) called with arguments", componentName, objectName, payload, payloadSizeBytes);
    if ((NULL == componentName) || (NULL == objectName))
    {
        OsConfigLogError(log, "ComplianceMmiSet(%s, %s, %s, %d) called with invalid arguments", componentName, objectName, payload, payloadSizeBytes);
        return EINVAL;
    }

    JSON_Value *inputJSON = NULL;
    status = DecodeB64JSON(objectName, &inputJSON);
    if (0 != status) {
        OsConfigLogError(log, "ComplianceMmiSet failed to decode input JSON %s", objectName);
        return status;
    }
    std::shared_ptr<JSON_Value> inputJSONPtr(inputJSON, json_value_free);
    if (json_value_get_type(inputJSON) != JSONObject) {
        OsConfigLogError(log, "ComplianceMmiSet input JSON is not an object");
        return EINVAL;
    }
    JSON_Object *root = json_value_get_object(inputJSON);
    if (json_object_get_count(root) == 0) {
        // No object, nothing to do
        return 0;
    }
    const char *name = json_object_get_name(root, 0);


    if (!strcmp(name, "remediate")) {
        JSON_Value *value = json_object_get_value_at(root, 0);
        if (json_value_get_type(value) != JSONObject) {
            OsConfigLogError(log, "ComplianceMmiSet audit JSON is not an object");
            return EINVAL;
        }
        JSON_Object *subObject = json_value_get_object(value);
        if (EvaluateProcedure(subObject, true, logstream, log) != TRUE) {
            OsConfigLogError(log, "ComplianceMmiSet failed to evaluate procedure - %s", logstream.str().c_str());
            return EINVAL;
        }
    } else if (!strcmp(name, "parameters")) {
        JSON_Value *value = json_object_get_value_at(root, 0);
        if (json_value_get_type(value) != JSONObject) {
            OsConfigLogError(log, "ComplianceMmiSet audit JSON is not an object");
            return EINVAL;
        }
        JSON_Object *subObject = json_value_get_object(value);
        char *trimmedPayload = strndup(payload + 1, payloadSizeBytes - 2); // remove quotes
        gParameters = parseParameters(subObject, trimmedPayload);
        free(trimmedPayload);
    } else {
        OsConfigLogError(log, "ComplianceMmiSet root JSON is not an known object");
        return EINVAL;
    }
    OsConfigLogInfo(log, "ComplianceMmiSet(%s, %s, %s, %d) completed, result log '%s'", componentName, objectName, payload, payloadSizeBytes, logstream.str().c_str());
    return status;

};
